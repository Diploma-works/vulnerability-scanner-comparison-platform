import asyncio
from functools import wraps, partial
from typing import Callable, Tuple, Dict, Awaitable, Optional, List, Union

from docker import from_env, DockerClient
from docker.models.containers import Container
from loguru import logger


def sync_to_async(fun: Callable) -> Callable:
    @wraps(fun)
    async def wrapper(*args: Tuple, **kwargs: Dict) -> Callable:
        return await asyncio.get_event_loop().run_in_executor(
            None, partial(fun, *args, **kwargs)
        )

    return wrapper


class DockerProvider:
    __client: Optional[DockerClient] = None

    @sync_to_async
    def connect(self) -> Callable:
        if self.__client is None:
            self.__client = from_env()
            logger.info("Connected to Docker")

    @sync_to_async
    def disconnect(self) -> Callable:
        if self.__client is not None:
            self.__client.close()
            self.__client = None
            logger.info("Closed connection to Docker")

    @sync_to_async
    def get_container_by_id(self, container_id: str) -> Awaitable[Container]:
        return self.__client.containers.get(container_id)

    @sync_to_async
    def start_container(
            self,
            image_name: str,
            command: str,
            name: str,
            volumes: Optional[Union[Dict, List[str]]] = None,
            env_variables: Optional[Union[Dict, List[str]]] = None,
    ) -> Awaitable[Container]:
        props = {"volumes": volumes} if volumes else {}
        if env_variables:
            props.update({"environment": env_variables})
        return self.__client.containers.run(image=image_name, command=command, name=name, **props, detach=True)

    @sync_to_async
    def get_containers(
            self,
            ids: Optional[Union[str, List[str]]] = None,
    ) -> Awaitable[List[Container]]:
        containers = self.__client.containers.list(all=True)
        if ids:
            formatted_ids = [ids] if isinstance(ids, str) else ids
            containers = list(filter(lambda c: c.id in formatted_ids, containers))
        return containers

    @sync_to_async
    def remove_container(
            self,
            container_id: str
    ) -> Callable:
        container = self.__client.containers.get(container_id)
        if container:
            container.remove(force=True)
