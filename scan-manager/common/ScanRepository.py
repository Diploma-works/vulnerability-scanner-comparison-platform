from datetime import datetime
from typing import List, Optional
from pypika.queries import Table, Query, QueryBuilder
from app.db import BaseRepository
from app.models.common import Id
from app.models.scan import Scan

scan = Table('scan')


class ScanRepository(BaseRepository):

    async def get_scans(
            self,
    ) -> List[Scan]:
        q: QueryBuilder = Query().from_(scan).select('*')
        return await self.fetch_rows(q, serializer=Scan)

    async def insert_scan(
            self,
            target_id: int,
            scanner_id: int,
            started_at: datetime,
            finished_at: Optional[datetime],
            status_id: int,
            report_path: Optional[str]
    ) -> int:
        q: QueryBuilder = Query().into(scan).columns(
            'target_id', 'scanner_id', 'started_at', 'finished_at', 'status_id', 'report_path'
        ).insert(
            target_id, scanner_id, started_at, finished_at, status_id, report_path
        )
        q: str = f"{q} RETURNING id"
        return (await self.fetch_one(q, serializer=Id)).id

    async def set_scan_report_path(self, scan_id: int, report_path: str) -> None:
        q: QueryBuilder = scan.update().set(scan.report_path, report_path).where(scan.id == scan_id)
        await self.execute(q)

    async def set_scan_status(self, scan_id: int, status_id: int) -> None:
        q: QueryBuilder = scan.update().set(scan.status_id, status_id).where(scan.id == scan_id)
        await self.execute(q)

    async def set_scan_finish_time(self, scan_id: int, finished_at: Optional[datetime]) -> None:
        q: QueryBuilder = scan.update().set(scan.finished_at, finished_at).where(scan.id == scan_id)
        await self.execute(q)
