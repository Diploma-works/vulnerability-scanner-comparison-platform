from aio_pika import connect_robust, Message
from aio_pika.abc import AbstractRobustConnection, AbstractRobustChannel, AbstractRobustExchange, AbstractRobustQueue, \
    ExchangeType, DeliveryMode
from loguru import logger
from pydantic import BaseModel

ANALYZE_QUEUE_NAME = "analyze"
DEFAULT_EXCHANGE_NAME = "default"


class RabbitMQClient:
    __connection: AbstractRobustConnection | None = None
    __channel: AbstractRobustChannel | None = None
    __exchange: AbstractRobustExchange | None = None
    __queue: AbstractRobustQueue | None = None

    async def disconnect(self) -> None:
        if self.__channel and not self.__channel.is_closed:
            await self.__channel.close()
        if self.__connection and not self.__connection.is_closed:
            await self.__connection.close()
        self.__connection = None
        self.__channel = None
        logger.debug('RabbitMQ disconnected')

    async def connect(self, url: str) -> None:
        try:
            self.__connection = await connect_robust(url)
            self.__channel = await self.__connection.channel(publisher_confirms=False)
            self.__exchange = await self.__channel.declare_exchange(DEFAULT_EXCHANGE_NAME, ExchangeType.DIRECT)
            self.__queue = await self.__channel.declare_queue(ANALYZE_QUEUE_NAME, durable=False, auto_delete=False)
            await self.__queue.bind(self.__exchange, routing_key=ANALYZE_QUEUE_NAME)
            logger.debug('Connected to RabbitMQ')
        except Exception as e:
            print("RabbitMQ has an error in attempt of connection")
            raise e

    async def send_message(self, message: BaseModel, routing_key: str) -> None:
        rabbit_message = await self.create_message(message)
        await self.__exchange.publish(message=rabbit_message, routing_key=routing_key)

    @staticmethod
    async def create_message(message: BaseModel) -> Message:
        return Message(body=message.model_dump_json().encode(), delivery_mode=DeliveryMode.PERSISTENT)
