from datetime import datetime
from typing import Tuple, Optional

from docker.models.containers import Container
from loguru import logger

from common import DockerProvider
from common.RabbitMQClient import RabbitMQClient
from common.enums import ScanStatus
from common.models import ScanFinishedMessage
from watcher.PostgresDB import PostgresDB


class DockerEventsHandler:
    def __init__(
            self,
            docker_provider: DockerProvider,
            postgres: PostgresDB,
            rabbitmq_client: RabbitMQClient
    ) -> None:
        self.__docker_provider = docker_provider
        self.__postgres = postgres
        self.__rabbitmq_client = rabbitmq_client

    @staticmethod
    def last_update_time(container: Container) -> datetime | None:
        finish_time = next(iter(container.attrs.get("State", {}).get("FinishedAt", "").split("."))).strip("Z")
        start_time = next(iter(container.attrs.get("State", {}).get("StartedAt", "").split("."))).strip("Z")
        finish_time = datetime.strptime(finish_time + "Z", "%Y-%m-%dT%H:%M:%SZ") if finish_time else datetime.now()
        start_time = datetime.strptime(start_time + "Z", "%Y-%m-%dT%H:%M:%SZ") if start_time else datetime.now()
        return start_time if start_time > finish_time else finish_time

    @staticmethod
    def update_container_info(container: Container, exit_code: int) -> Tuple[
        ScanStatus, Optional[str], Optional[datetime]]:
        status = container.attrs.get("State", {}).get("Status", "unknown")
        error_code = container.attrs.get("State", {}).get("ExitCode", None)
        error_message = container.attrs.get("State", {}).get("Error", "")
        last_datetime = DockerEventsHandler.last_update_time(container)

        if status != "running":
            if isinstance(error_code, int) and error_code != exit_code:
                return ScanStatus.ATTACK_ERROR, error_message, last_datetime
            else:
                return ScanStatus.ATTACK_FINISH, "", last_datetime
        else:
            return ScanStatus.IN_PROGRESS, None, None

    async def update_scans_statuses(self) -> None:
        scans_to_watch = await self.__postgres.scan_container_info.get_scan_container_info()
        logger.debug(f"Scans to watch: {len(scans_to_watch)}")
        for scan in scans_to_watch:
            scan_container = await self.__docker_provider.get_container_by_id(scan.container_id)
            status, error, finished_at = self.update_container_info(scan_container, scan.exit_code)
            if status != ScanStatus.IN_PROGRESS:
                logger.info(
                    f"Scan with id {scan.scan_id} has occurred an error: {error}") if status == ScanStatus.ATTACK_ERROR else logger.info(
                    f"Scan with id {scan.scan_id} has finished")
                await self.__postgres.scan_container_info.remove_scan_container_info(scan.scan_id)
                await self.__postgres.scan.set_scan_status(scan.scan_id, status)
                await self.__postgres.scan.set_scan_finish_time(scan.scan_id, finished_at)
                if status != ScanStatus.ATTACK_ERROR:
                    await self.__rabbitmq_client.send_message(ScanFinishedMessage(scan_id=scan.scan_id), 'analyze')
                await self.__docker_provider.remove_container(scan.container_id)
            else:
                logger.info(f"Scan {scan.scan_id} in progress")
