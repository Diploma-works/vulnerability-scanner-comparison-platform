from contextlib import asynccontextmanager
from typing import Any
from typing import Callable
from typing import List
from typing import Optional
from typing import Type
from typing import Union

from asyncpg import Connection
from asyncpg import Pool
from fastapi import Depends
from fastapi.requests import Request
from pydantic import BaseModel
from pypika.queries import QueryBuilder


class BaseRepository:
    def __init__(self, connection_pool):
        self.connection_pool: Pool = connection_pool
        self.__transactional_connection: Optional[Connection] = None

    @property
    def connection(self) -> Union[Connection, Pool]:
        return self.__transactional_connection or self.connection_pool

    @asynccontextmanager
    async def transaction(self):
        try:
            async with self.connection_pool.acquire() as connection:
                async with connection.transaction():
                    self.__transactional_connection = connection
                    yield connection
        finally:
            self.__transactional_connection = None

    async def fetch_rows(
        self, query: Union[str, QueryBuilder], *args, serializer: Type[BaseModel] = BaseModel
    ) -> List[Any]:
        result = await self.connection.fetch(str(query), *args)

        if not result:
            return []

        result = list(map(lambda x: serializer.construct(**dict(x.items())), result))  # noqa
        return result

    async def fetch_one(self, query: Union[str, QueryBuilder], *args, serializer: Type[BaseModel] = BaseModel) -> Any:
        result = await self.connection.fetchrow(str(query), *args)

        if not result:
            return None

        result = serializer.construct(**dict(result.items()))
        return result

    async def execute(self, query: Union[str, QueryBuilder], *args) -> str:
        result = await self.connection.execute(str(query), *args)
        return result


def _get_db_pool(request: Request) -> Pool:
    return request.app.state.db_pool


def get_repository(
    repo_type: Type[BaseRepository],
) -> Callable[[Pool], BaseRepository]:
    def _get_repo(
        connection_pool: Pool = Depends(_get_db_pool),
    ) -> BaseRepository:
        return repo_type(connection_pool)

    return _get_repo
