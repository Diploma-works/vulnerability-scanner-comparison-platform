import os
from typing import Optional

from asyncpg import Pool, create_pool
from loguru import logger

from common.db.ScanRepository import ScanRepository
from common.db.VulnerabilityRepository import VulnerabilityRepository


def get_postgres_url() -> str:
    user = os.environ.get("DB_USER", "postgres")
    password = os.environ.get("DB_PASSWORD", "postgres")
    host = os.environ.get("DB_HOST", "localhost")
    port = os.environ.get("DB_PORT", "5434")
    db = os.environ.get("DB_NAME", "analytic-service")
    return f"postgres://{user}:{password}@{host}:{port}/{db}"


class PostgresDB:
    __pool: Optional[Pool] = None
    __url: Optional[str] = None
    __scan: Optional[ScanRepository] = None
    __vulnerability: Optional[VulnerabilityRepository] = None

    async def connect(self, url: Optional[str]) -> None:
        if self.__url is None:
            self.__url = url
        try:
            self.__pool = await create_pool(dsn=url)
            logger.debug('Connected to PostgresDB')
        except Exception as e:
            raise RuntimeError(e)

    async def disconnect(self) -> None:
        if self.__pool is not None:
            await self.__pool.close()
            self.__pool = None
            logger.debug('Connection to PostgresDB closed')

    @property
    def scan(self) -> ScanRepository:
        if self.__scan is None:
            self.__scan = ScanRepository(self.__pool)
            logger.debug('Access to Scan table has provided')
        return self.__scan

    @property
    def vulnerability(self) -> VulnerabilityRepository:
        if self.__vulnerability is None:
            self.__vulnerability = VulnerabilityRepository(self.__pool)
            logger.debug('Access to Scan table has provided')
        return self.__vulnerability
