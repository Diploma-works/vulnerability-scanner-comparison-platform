import pathlib
from typing import Dict

from aioscrapy.crawler import CrawlerProcess
from loguru import logger

from app.models.errors import SCAN_NOT_FOUND
from common.db.ScanRepository import ScanRepository
from common.db.VulnerabilityRepository import VulnerabilityRepository
from common.models.errors import AnalyzeException
from common.parsers import SCANNER_PARSER_MAP
from common.utils.ScanStatus import ScanStatus


class AnalyzeService:

    def __init__(
            self,
            default_scan_resource_path: str = "/home/mstepanov/scans/"
    ):
        self.vulner_repo: VulnerabilityRepository | None = None
        self.scan_repo: ScanRepository | None = None
        self.catalog_service_client = None
        self.__default_scan_resource_path = default_scan_resource_path

    async def __get_vulnerabilities_group_map(self) -> Dict[str, Dict[str, int]]:
        groups_list = await self.catalog_service_client.get_vulnerabilities_groups()
        scores_map = dict(map(lambda x: (x.id, x.score), groups_list.groups))
        vulnerabilities_types_list = await self.catalog_service_client.get_vulnerabilities_types()
        vulners_name_type_map = dict(
            map(lambda x: (x.name, {"group_id": x.group_id, "score": scores_map.get(x.group_id, 0)}),
                vulnerabilities_types_list.types))  # noqa
        return vulners_name_type_map

    async def analyze_scan_report(
            self, scan_id: int,
            clear_vulnerabilities: bool = True
    ) -> None:
        """
        :param clear_vulnerabilities:
        :param scan_id:
        :return:
        :raises AnalyzeException - исключение, если не найден целевой скан
        """
        scan = await self.scan_repo.get_scan_by_param(scan_id=scan_id)
        if not scan:
            raise AnalyzeException(404, SCAN_NOT_FOUND)
        parser = SCANNER_PARSER_MAP.get(scan.scanner_id)
        scan_path = pathlib.Path(f"{self.__default_scan_resource_path}/{scan.report_path}").as_uri()
        vulners_name_type_map = await self.__get_vulnerabilities_group_map()

        if clear_vulnerabilities and scan.status_id == ScanStatus.ANALYSIS_FINISH:
            duplicates = await self.vulner_repo.get_vulnerabilities_with_duplicates_by_scan_id(scan_id)
            duplicates_ids = [duplicate.vulner_id for duplicate in duplicates]
            if duplicates_ids:
                await self.vulner_repo.delete_vulnerabilities_duplicates_by_ids(duplicates_ids)
            await self.vulner_repo.delete_vulnerabilities_duplicates_by_scan_id(scan_id)

        logger.info(f"Scan {scan_id} started analyze report. Report path: {scan_path}")
        process = CrawlerProcess()
        process.crawl(
            parser,
            scan.id, scan_path, vulners_name_type_map, self.vulner_repo, self.scan_repo
        )
        await process.run()
        await process.stop()
        # scan = await self.scan_repo.get_scan_by_param(scan_id=scan_id)
        # if scan.status_id == ScanStatus.ANALYSIS_FINISH:
        #     await self.scan_repo.set_scan_status(scan_id, ScanStatus.FINISH)
        logger.info(f"Scan {scan.id} finished analyzing")
