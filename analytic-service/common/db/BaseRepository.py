from contextlib import asynccontextmanager
from typing import Optional, Union, Type, Any, List

from asyncpg import Pool, Connection
from pydantic import BaseModel
from pypika.queries import QueryBuilder


class BaseRepository:
    def __init__(self, connection_pool):
        self.connection_pool: Pool = connection_pool
        self.__transactional_connection: Optional[Connection] = None

    @property
    def connection(self) -> Union[Connection, Pool]:
        return self.__transactional_connection or self.connection_pool

    @asynccontextmanager
    async def transaction(self):
        try:
            async with self.connection_pool.acquire() as connection:
                async with connection.transaction():
                    self.__transactional_connection = connection
                    yield connection
        finally:
            self.__transactional_connection = None

    async def fetch_rows(
            self, query: Union[str, QueryBuilder], *args, serializer: Type[BaseModel] = BaseModel
    ) -> List[Any]:
        result = await self.connection.fetch(str(query), *args)

        if not result:
            return []

        result = list(map(lambda x: serializer.construct(**dict(x.items())), result))  # noqa
        return result

    async def fetch_one(self, query: Union[str, QueryBuilder], *args, serializer: Type[BaseModel] = BaseModel) -> Any:
        result = await self.connection.fetchrow(str(query), *args)

        if not result:
            return None

        result = serializer.construct(**dict(result.items()))
        return result

    async def execute(self, query: Union[str, QueryBuilder], *args) -> str:
        result = await self.connection.execute(str(query), *args)
        return result
