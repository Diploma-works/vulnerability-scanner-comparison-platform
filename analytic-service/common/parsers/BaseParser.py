import json
from enum import Enum
from itertools import groupby
from json import JSONDecodeError
from typing import Optional, List, Dict

from aioscrapy import Spider, Request
from aioscrapy.http import HtmlResponse
from loguru import logger

from common.db.ScanRepository import ScanRepository
from common.db.VulnerabilityRepository import VulnerabilityRepository
from common.models.vulnerability import ParsedVulnerability
from common.utils.ScanStatus import ScanStatus
from common.utils.Severity import Severity


class ParserType(Enum):
    JSON = "json"
    HTML = "html"


class BaseParser(Spider):
    custom_settings = {
        "CLOSE_SPIDER_ON_IDLE": True,
        "HTTPPROXY_ENABLED": False,
        "LOG_LEVEL": "DEBUG",
        "DOWNLOAD_MAXSIZE": 0,
        "DOWNLOAD_WARNSIZE": 0,
        "DOWNLOAD_TIMEOUT": 0,
        "URLLENGTH_LIMIT": 0,
        "EXTENSIONS": {},
        "EXTENSIONS_BASE": {},
        "SPIDER_MIDDLEWARES": {},
        "SPIDER_MIDDLEWARES_BASE": {},
        "DOWNLOADER_MIDDLEWARES": {},
        "DOWNLOADER_MIDDLEWARES_BASE": {},
        "DOWNLOADER_STATS": False,
        "DOWNLOAD_HANDLERS_BASE": {},
        "DOWNLOAD_HANDLERS": {
            "file": "common.parsers.LocalFileDownloader",
        }
    }
    parser_type: ParserType

    def __init__(
            self,
            scan_id: int,
            report_path: str,
            vulner_group_name_map: Dict[str, Dict[str, int]],
            vulnerability_repo: VulnerabilityRepository,
            scan_repository: ScanRepository,
    ):
        super().__init__()
        self.scan_id = scan_id
        self.report_path = report_path
        self.vulnerability_repo = vulnerability_repo
        self.scan_repository = scan_repository
        self.vulner_group_name_map = vulner_group_name_map
        self.parsed_vulnerabilities: Optional[List[ParsedVulnerability]] = []

    @property
    def name(self):
        return self.__class__.__name__

    async def parse(self, response: HtmlResponse):
        raise NotImplemented

    async def start_requests(self):
        return Request(
            url=self.report_path,
            callback=self.parsing_end_handle,
            use_proxy=False
        )

    @staticmethod
    async def process_exception(request: Request, response: HtmlResponse, spider: Spider):
        logger.error(f"Exception has caught")

    async def parsing_end_handle(self, response: HtmlResponse):
        await self.scan_repository.set_scan_status(self.scan_id, ScanStatus.ANALYSIS)
        await self.parse(response)
        if len(self.parsed_vulnerabilities) != 0:
            await self.insert_parsed_vulnerabilities()
            await self.scan_repository.set_scan_status(self.scan_id, ScanStatus.ANALYSIS_FINISH)
        else:
            await self.scan_repository.set_scan_status(self.scan_id, ScanStatus.ANALYSIS_ERROR)

    async def insert_parsed_vulnerabilities(self) -> None:
        async with self.vulnerability_repo.transaction():
            for name, vulner_group in groupby(self.parsed_vulnerabilities, key=lambda v: v.name):
                origin_vulnerability_id = None
                duplicate_vulnerabilities_ids = list()

                for item in list(vulner_group):
                    vulnerability_id = await self.vulnerability_repo.insert_vulnerability(
                        scan_id=self.scan_id,
                        group_id=item.vuln_group_id,
                        severity_id=item.severity_id,
                        name=item.name,
                        vector=item.vector,
                        method=item.request.get('method', None),
                        url=item.request.get('url', None),
                        path=item.request.get('path', None),
                        params=item.request.get('query', None),
                        is_false_positive=item.is_false_positive,
                    )

                    if item.is_duplicate is not None:
                        if item.is_duplicate is False:
                            origin_vulnerability_id = vulnerability_id
                        else:
                            duplicate_vulnerabilities_ids.append(vulnerability_id)

                if origin_vulnerability_id is not None and duplicate_vulnerabilities_ids:
                    await self.vulnerability_repo.insert_vulnerability_duplicates(
                        origin_vulnerability_id,
                        duplicate_vulnerabilities_ids
                    )

    @staticmethod
    def parse_json(report: bytes) -> Optional[dict]:
        try:
            report_data = json.loads(report)
        except JSONDecodeError:
            report_data = None
        return report_data

    def extract_data_from_response(self, response: HtmlResponse) -> dict:
        if self.parser_type == ParserType.HTML:
            raise AttributeError(
                f"Метод недоступен для {self.parser_type.name}-парсера {self.name}"
            )
        if self.parser_type == ParserType.JSON:
            return self.parse_json(response.body)

    async def get_vuln_group_id_and_severity_id(self, name: str) -> (int, Severity):
        name = name.strip(' ')
        vulnerability_group_info = self.vulner_group_name_map.get(name)

        if vulnerability_group_info is None:
            self.vulner_group_name_map[name] = {
                "group_id": 0,
                "score": 0
            }
            vulnerability_group_info = self.vulner_group_name_map[name]

        score = vulnerability_group_info["score"]
        severity_id = Severity.get_severity_by_score(score).value

        return vulnerability_group_info["group_id"], severity_id
