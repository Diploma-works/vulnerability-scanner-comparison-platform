import email
from io import StringIO
from typing import Optional
from urllib.parse import urlparse, unquote


class Request:
    def __init__(self, url, method, headers: Optional[dict] = None, body: Optional[str] = None):
        self.url = url
        self.headers = headers
        self.method = method
        self.scheme, self.host, self.path, self.params, self.query, self.fragment = urlparse(url)
        self.params = self.params if self.params else None
        self.query = self.query if self.query else None
        self.query_params = self.params_to_dict(self.query)
        self.body = body
        self.body_params = self.params_to_dict(body)
        self.domain = f"{self.scheme}://{self.host}" if all((self.scheme, self.host)) else ''

    @classmethod
    def from_raw(cls, raw: str):
        stream = StringIO(raw)
        request = stream.readline()
        words = request.split()
        method, path, version = words
        content = stream.read().split('\n\n')
        headers = content[0]
        body = content[1] if len(content) > 1 else ''
        headers = dict(email.message_from_string(headers).items())
        return cls(url=path, method=method, headers=headers, body=body)

    def __str__(self):
        return self.as_string()

    def __repr__(self):
        return self.as_string()

    def as_string(self):
        return f'\n\tmethod: {self.method}\n\tpath: {self.path}\n\tparams: {self.params}\n\tquery: {self.query}' \
               f'\n\tquery_as_dict: {self.query_params}\n\theaders: {self.headers}\n\tbody: {self.body}' \
               f'\n\tbody_as_dict: {self.body_params}\n\t'

    def as_dict(self):
        return {
            "url": self.url,
            "method": self.method,
            "path": self.path,
            "params": self.params,
            "query": self.query,
            "headers": self.headers,
            "body": self.body,
        }

    def __hash__(self):
        return hash((self.path, self.method))

    @staticmethod
    def params_to_dict(params: str) -> dict:
        output = {}
        if not params:
            return output
        for parameter in params.split('&'):
            try:
                name, value = parameter.split('=', maxsplit=1)
                output[name] = unquote(value, encoding='utf-8')
            except ValueError:
                pass
        return output

    def get_attack_vector(self, parameter: Optional[str] = None) -> Optional[str]:
        if not parameter:
            return self.query

        for key, value in self.body_params.items():
            if key == parameter:
                return f"{key}={self.body_params[key]}"
