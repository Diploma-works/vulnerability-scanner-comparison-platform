import os
from typing import Callable, Any

from aio_pika import connect_robust, Message
from aio_pika.abc import AbstractRobustConnection, AbstractRobustChannel, AbstractRobustExchange, AbstractRobustQueue, \
    ExchangeType, DeliveryMode, AbstractIncomingMessage
from pydantic import BaseModel

ANALYZE_QUEUE_NAME = "analyze"
DEFAULT_EXCHANGE_NAME = "default"


def get_rabbit_url() -> str:
    password = os.environ.get("RABBITMQ_PASSWORD", "rmpassword")
    user = os.environ.get("RABBITMQ_USER", "rmuser")
    host = os.environ.get("RABBITMQ_HOST", "localhost")
    port = os.environ.get("RABBITMQ_PORT", 5672)
    return f"amqp://{user}:{password}@{host}:{port}"


class RabbitMQClient:
    def __init__(self):
        pass

    __connection: AbstractRobustConnection | None = None
    __channel: AbstractRobustChannel | None = None
    __exchange: AbstractRobustExchange | None = None
    __queue: AbstractRobustQueue | None = None

    async def disconnect(self) -> None:
        if self.__channel and not self.__channel.is_closed:
            await self.__channel.close()
        if self.__connection and not self.__connection.is_closed:
            await self.__connection.close()
        self.__connection = None
        self.__channel = None

    async def connect(self, url: str) -> None:
        try:
            self.__connection = await connect_robust(url)
            self.__channel = await self.__connection.channel(publisher_confirms=False)
            self.__exchange = await self.__channel.declare_exchange(DEFAULT_EXCHANGE_NAME, ExchangeType.DIRECT)
            self.__queue = await self.__channel.declare_queue(ANALYZE_QUEUE_NAME, durable=False, auto_delete=False)
            await self.__queue.bind(self.__exchange, routing_key=ANALYZE_QUEUE_NAME)
        except Exception as e:
            raise self.error(e) from e  # TODO Доделать обработку ошибок

    async def send_message(self, message: BaseModel, routing_key: str) -> None:
        rabbit_message = await self.create_message(message)
        await self.__exchange.publish(message=rabbit_message, routing_key=routing_key)

    async def consume(self, message_handler: Callable[[AbstractIncomingMessage], Any]) -> None:
        await self.__queue.consume(message_handler)

    @staticmethod
    async def create_message(message: BaseModel) -> Message:
        return Message(body=message.model_dump_json().encode(), delivery_mode=DeliveryMode.PERSISTENT)
